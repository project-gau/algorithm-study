# 4주차 gold 해설

## 1. 내리막길

* dp 테이블을 뭐라고 정의하는 지가 주요했다.
* 각 `dp[i][j]` = i,j로부터 N-1,M-1까지 가는 경우의 수

그래서 주어진 예제의 경우, 아래와 같이 dp 테이블이 나와야 한다.

<img width="450" alt="image" src="https://user-images.githubusercontent.com/51740388/181186454-644913a2-6194-4741-9fff-3c40186c5d5f.png">

<img width="450" alt="image" src="https://user-images.githubusercontent.com/51740388/181187501-fe3604e4-7b6f-4fb5-9a9a-8d1d8fd31f16.png">

* `dp[x][y] += recurse(nx,ny)` 를 해주는 것이 주요한 포인트였다.
  * 위 경우 왼쪽 위에서 왼쪽 아래로 쭉 뻗는 형태가 된다.
  * 이 때, visited를 안해줘도 되는데 그 이유는 높이가 높은 값에서 낮은 값으로의 호출만 일어나기 때문에 ( `if map[x][y] > map[nx][ny]` ) 순환호출이 일어날 일이 없기 때문이다.

## 2. 동전2

* 동전1의 경우 모든 경우의 수를 찾는 게 문제였다면, 동전2의 경우 최소의 경우의 수를 찾는게 문제였다.
* K(목표 값)까지 동전의 값을 돌려주면서 순회를 해준다.
  * 이 때, `dp[i-arr[j]]` 의 값이 `Integer.MAX_VALUE` 라면, 즉 `bottom-up` 에서 일어날 수 없는 값이라면 해당 경우의 수에서 1을 더해주면 안된다.
  * 그래서 해당 값을 제외해주어야 한다.

## 3. 성냥개비

* 네이버 기출문제였다.
* 이해하는데 시간이 좀 걸렸는데, 어떻게 보면 별 거 없는 문제였던 것 같다.
* DP문제가 까다로운 이유는 어느 항의 값까지 구해보고 나서 점화식을 적용해봐야 할 지, 어떻게 아이디어를 적용해서 점화식을 도출해낼 지 생각하는 게 어렵다.
* 최대값의 경우 생각해내는 게 어렵지 않았다.
  * 최대값만 문제를 냈으면 실버급 문제가 아니었을까 싶다.
  * 홀수, 짝수 일 때 나눠서 값을 생성해준다.
* 최소값의 경우 일단 `dp[2]~dp[8]` 값 까지 구한다.
  * 성냥개비의 각 cost는 `2~7`인데 왜 8까지 구하냐면, cost가 6일 때 0이 만들어 질 수 있고, 해당 값으로 01 값이 도출될 수 있기 때문이다.
  * cost를 구해보면 모든 값이 사용되지 않는 것을 알 수 있다.
    * 예를 들어, cost가 5일 때 나올 수 있는 경우의 수는 2,3,5 가 있는데 어차피 2가 최소값이므로 2밖에 사용되지 않는다.
    * 고로 cost가 5일 때는 2로 고정시켜놓는다.
      * 위 놀리로 값을 구해보면, `int[] cost = {0,0,1,7,4,2,0,8}` 가 나온다. ( 2일 때 1, 3일 때 7, ...)
* 9의 값부터는 `동전1,2문제`와 로직이 같다.
  * `dp[i] = Math.min(dp[i], dp[i-j] + arr[j])`
  * 이 때, dp의 값은 Long.MAX_VALUE로 초기화 돼 있어야 한다.
  * 또 String -> Long으로 변환해주어야 한다.
* 동전1,2문제의 응용문제라고도 볼 수 있을 것 같은데, 해당 아이디어를 떠올리는 것은 상당히 어려운 것 같다.

## 4. 타일채우기

* dp가 까다로운 이유 중 하나다.
* `f(4)` 를 **구해보니** 예외케이스가 2개 나온다.
  * 그리고 모든 경우에 예외케이스가 딱 2개씩만 나온다.
    * 이 모든 경우에 예외케이스가 2개**만** 나온다는 것을 확신할 수 있어야 하는데, 이 확신이 상당히 어려운 것 같다.
* `f(6)` 의 경우, 기존값 f(4)*f(2), 를 더해주고, f(2) * 2`(f(4)의 예외케이스)`를 더해주면 해당 f(4)*f(2)와 겹치지 않게 된다.
  * 그리고 f(6)의 예외케이스 2개를 더해준다.
* f(8)의 경우 기존값 f(6)*f(2)를 더해주고, f(4) * 2 `(f(4) 의 예외케이스)` , f(2) * 2 (`f(6)의 예외케이스`) , 2(`f(8)의 예외케이스`) 를 더해주면 된다.

## 5. 파일합치기

* 문제의 핵심 중 하나는 `N = 500`이라는 것이다.
  * 500 * 500 * 500 은 1억 4천정도 나오는데, 이는 아슬아슬하게 `O(n^3)` 정도에 걸릴 시간복잡도다.
  * N=500이 O(n^3)의 마지노선이다.
  * (문제 설정에 따라서 시간초과로 나올 수도 있다.)
* 문제의 아이디어는 다음과 같다.
  
<img width="500" alt="image" src="https://user-images.githubusercontent.com/51740388/181196340-9ecc8bab-851b-483e-a22b-81b9562830e9.png">

* `dp[i][j]` 가 의미하는 것은 i부터 j까지의 최소 파일 비용
  * dp[1][1+1], dp[2][2+1], dp[3][3+1], ...
  * dp[1][1+2], dp[2][2+2], ...
  * dp[1][1+3], ...
* 위와 같이 j값을 늘려주면서,`dp[1][N]` 까지 늘려준다.
* 이 때, `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])` 로 쪼개주면서 최소값을 갱신해준다.
* 아이디어를 떠올리는게 상당히 어려운 문제였다.
  * i~j까지 전체 길이의 값을 더해줘야 하므로, prefixSum을 생성해서 위 식에 전체 길이를 더해준다.

## 6. 합분해

* 아이디어를 떠올리는 게 힘들었다.
* 5,3 이라고 하면 
  * 5 = 0(2번 더해서 0) + 5
  * 5 = 1(2번 더해서 1) + 4
  * ...
* `dp[3][5] = dp[2][0] + dp[2][1] + ... + dp[2][5]` 이다.
* 이 때, `dp[2][0] ~ dp[2][4]까지의 합은 dp[3][4]`에 저장 돼 있다.
  * 아래 그림 참조

<img width="500" alt="image" src="https://user-images.githubusercontent.com/51740388/181199776-8e994044-77c0-4e86-8ec4-33b8570e9c97.png">

* 그러므로 `dp[3][5]` = `dp[3][4] + dp[2][5]` 로 식이 만들어진다.
  * 곧, `dp[i][j] = `dp[i][j-1] + dp[i-1][j]`이다.